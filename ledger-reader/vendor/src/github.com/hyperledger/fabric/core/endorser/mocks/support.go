// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/resourcesconfig"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"golang.org/x/net/context"
)

type Support struct {
	IsSysCCAndNotInvokableExternalStub        func(name string) bool
	isSysCCAndNotInvokableExternalMutex       sync.RWMutex
	isSysCCAndNotInvokableExternalArgsForCall []struct {
		name string
	}
	isSysCCAndNotInvokableExternalReturns struct {
		result1 bool
	}
	isSysCCAndNotInvokableExternalReturnsOnCall map[int]struct {
		result1 bool
	}
	GetTxSimulatorStub        func(ledgername string, txid string) (ledger.TxSimulator, error)
	getTxSimulatorMutex       sync.RWMutex
	getTxSimulatorArgsForCall []struct {
		ledgername string
		txid       string
	}
	getTxSimulatorReturns struct {
		result1 ledger.TxSimulator
		result2 error
	}
	getTxSimulatorReturnsOnCall map[int]struct {
		result1 ledger.TxSimulator
		result2 error
	}
	GetHistoryQueryExecutorStub        func(ledgername string) (ledger.HistoryQueryExecutor, error)
	getHistoryQueryExecutorMutex       sync.RWMutex
	getHistoryQueryExecutorArgsForCall []struct {
		ledgername string
	}
	getHistoryQueryExecutorReturns struct {
		result1 ledger.HistoryQueryExecutor
		result2 error
	}
	getHistoryQueryExecutorReturnsOnCall map[int]struct {
		result1 ledger.HistoryQueryExecutor
		result2 error
	}
	GetTransactionByIDStub        func(chid, txID string) (*pb.ProcessedTransaction, error)
	getTransactionByIDMutex       sync.RWMutex
	getTransactionByIDArgsForCall []struct {
		chid string
		txID string
	}
	getTransactionByIDReturns struct {
		result1 *pb.ProcessedTransaction
		result2 error
	}
	getTransactionByIDReturnsOnCall map[int]struct {
		result1 *pb.ProcessedTransaction
		result2 error
	}
	IsSysCCStub        func(name string) bool
	isSysCCMutex       sync.RWMutex
	isSysCCArgsForCall []struct {
		name string
	}
	isSysCCReturns struct {
		result1 bool
	}
	isSysCCReturnsOnCall map[int]struct {
		result1 bool
	}
	ExecuteStub        func(ctxt context.Context, cid, name, version, txid string, syscc bool, signedProp *pb.SignedProposal, prop *pb.Proposal, spec interface{}) (*pb.Response, *pb.ChaincodeEvent, error)
	executeMutex       sync.RWMutex
	executeArgsForCall []struct {
		ctxt       context.Context
		cid        string
		name       string
		version    string
		txid       string
		syscc      bool
		signedProp *pb.SignedProposal
		prop       *pb.Proposal
		spec       interface{}
	}
	executeReturns struct {
		result1 *pb.Response
		result2 *pb.ChaincodeEvent
		result3 error
	}
	executeReturnsOnCall map[int]struct {
		result1 *pb.Response
		result2 *pb.ChaincodeEvent
		result3 error
	}
	GetChaincodeDefinitionStub        func(ctx context.Context, chainID string, txid string, signedProp *pb.SignedProposal, prop *pb.Proposal, chaincodeID string, txsim ledger.TxSimulator) (resourcesconfig.ChaincodeDefinition, error)
	getChaincodeDefinitionMutex       sync.RWMutex
	getChaincodeDefinitionArgsForCall []struct {
		ctx         context.Context
		chainID     string
		txid        string
		signedProp  *pb.SignedProposal
		prop        *pb.Proposal
		chaincodeID string
		txsim       ledger.TxSimulator
	}
	getChaincodeDefinitionReturns struct {
		result1 resourcesconfig.ChaincodeDefinition
		result2 error
	}
	getChaincodeDefinitionReturnsOnCall map[int]struct {
		result1 resourcesconfig.ChaincodeDefinition
		result2 error
	}
	CheckACLStub        func(signedProp *pb.SignedProposal, chdr *common.ChannelHeader, shdr *common.SignatureHeader, hdrext *pb.ChaincodeHeaderExtension) error
	checkACLMutex       sync.RWMutex
	checkACLArgsForCall []struct {
		signedProp *pb.SignedProposal
		chdr       *common.ChannelHeader
		shdr       *common.SignatureHeader
		hdrext     *pb.ChaincodeHeaderExtension
	}
	checkACLReturns struct {
		result1 error
	}
	checkACLReturnsOnCall map[int]struct {
		result1 error
	}
	IsJavaCCStub        func(buf []byte) (bool, error)
	isJavaCCMutex       sync.RWMutex
	isJavaCCArgsForCall []struct {
		buf []byte
	}
	isJavaCCReturns struct {
		result1 bool
		result2 error
	}
	isJavaCCReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CheckInstantiationPolicyStub        func(name, version string, cd resourcesconfig.ChaincodeDefinition) error
	checkInstantiationPolicyMutex       sync.RWMutex
	checkInstantiationPolicyArgsForCall []struct {
		name    string
		version string
		cd      resourcesconfig.ChaincodeDefinition
	}
	checkInstantiationPolicyReturns struct {
		result1 error
	}
	checkInstantiationPolicyReturnsOnCall map[int]struct {
		result1 error
	}
	GetChaincodeDeploymentSpecFSStub        func(cds *pb.ChaincodeDeploymentSpec) (*pb.ChaincodeDeploymentSpec, error)
	getChaincodeDeploymentSpecFSMutex       sync.RWMutex
	getChaincodeDeploymentSpecFSArgsForCall []struct {
		cds *pb.ChaincodeDeploymentSpec
	}
	getChaincodeDeploymentSpecFSReturns struct {
		result1 *pb.ChaincodeDeploymentSpec
		result2 error
	}
	getChaincodeDeploymentSpecFSReturnsOnCall map[int]struct {
		result1 *pb.ChaincodeDeploymentSpec
		result2 error
	}
	GetApplicationConfigStub        func(cid string) (channelconfig.Application, bool)
	getApplicationConfigMutex       sync.RWMutex
	getApplicationConfigArgsForCall []struct {
		cid string
	}
	getApplicationConfigReturns struct {
		result1 channelconfig.Application
		result2 bool
	}
	getApplicationConfigReturnsOnCall map[int]struct {
		result1 channelconfig.Application
		result2 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Support) IsSysCCAndNotInvokableExternal(name string) bool {
	fake.isSysCCAndNotInvokableExternalMutex.Lock()
	ret, specificReturn := fake.isSysCCAndNotInvokableExternalReturnsOnCall[len(fake.isSysCCAndNotInvokableExternalArgsForCall)]
	fake.isSysCCAndNotInvokableExternalArgsForCall = append(fake.isSysCCAndNotInvokableExternalArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("IsSysCCAndNotInvokableExternal", []interface{}{name})
	fake.isSysCCAndNotInvokableExternalMutex.Unlock()
	if fake.IsSysCCAndNotInvokableExternalStub != nil {
		return fake.IsSysCCAndNotInvokableExternalStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isSysCCAndNotInvokableExternalReturns.result1
}

func (fake *Support) IsSysCCAndNotInvokableExternalCallCount() int {
	fake.isSysCCAndNotInvokableExternalMutex.RLock()
	defer fake.isSysCCAndNotInvokableExternalMutex.RUnlock()
	return len(fake.isSysCCAndNotInvokableExternalArgsForCall)
}

func (fake *Support) IsSysCCAndNotInvokableExternalArgsForCall(i int) string {
	fake.isSysCCAndNotInvokableExternalMutex.RLock()
	defer fake.isSysCCAndNotInvokableExternalMutex.RUnlock()
	return fake.isSysCCAndNotInvokableExternalArgsForCall[i].name
}

func (fake *Support) IsSysCCAndNotInvokableExternalReturns(result1 bool) {
	fake.IsSysCCAndNotInvokableExternalStub = nil
	fake.isSysCCAndNotInvokableExternalReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Support) IsSysCCAndNotInvokableExternalReturnsOnCall(i int, result1 bool) {
	fake.IsSysCCAndNotInvokableExternalStub = nil
	if fake.isSysCCAndNotInvokableExternalReturnsOnCall == nil {
		fake.isSysCCAndNotInvokableExternalReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSysCCAndNotInvokableExternalReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Support) GetTxSimulator(ledgername string, txid string) (ledger.TxSimulator, error) {
	fake.getTxSimulatorMutex.Lock()
	ret, specificReturn := fake.getTxSimulatorReturnsOnCall[len(fake.getTxSimulatorArgsForCall)]
	fake.getTxSimulatorArgsForCall = append(fake.getTxSimulatorArgsForCall, struct {
		ledgername string
		txid       string
	}{ledgername, txid})
	fake.recordInvocation("GetTxSimulator", []interface{}{ledgername, txid})
	fake.getTxSimulatorMutex.Unlock()
	if fake.GetTxSimulatorStub != nil {
		return fake.GetTxSimulatorStub(ledgername, txid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getTxSimulatorReturns.result1, fake.getTxSimulatorReturns.result2
}

func (fake *Support) GetTxSimulatorCallCount() int {
	fake.getTxSimulatorMutex.RLock()
	defer fake.getTxSimulatorMutex.RUnlock()
	return len(fake.getTxSimulatorArgsForCall)
}

func (fake *Support) GetTxSimulatorArgsForCall(i int) (string, string) {
	fake.getTxSimulatorMutex.RLock()
	defer fake.getTxSimulatorMutex.RUnlock()
	return fake.getTxSimulatorArgsForCall[i].ledgername, fake.getTxSimulatorArgsForCall[i].txid
}

func (fake *Support) GetTxSimulatorReturns(result1 ledger.TxSimulator, result2 error) {
	fake.GetTxSimulatorStub = nil
	fake.getTxSimulatorReturns = struct {
		result1 ledger.TxSimulator
		result2 error
	}{result1, result2}
}

func (fake *Support) GetTxSimulatorReturnsOnCall(i int, result1 ledger.TxSimulator, result2 error) {
	fake.GetTxSimulatorStub = nil
	if fake.getTxSimulatorReturnsOnCall == nil {
		fake.getTxSimulatorReturnsOnCall = make(map[int]struct {
			result1 ledger.TxSimulator
			result2 error
		})
	}
	fake.getTxSimulatorReturnsOnCall[i] = struct {
		result1 ledger.TxSimulator
		result2 error
	}{result1, result2}
}

func (fake *Support) GetHistoryQueryExecutor(ledgername string) (ledger.HistoryQueryExecutor, error) {
	fake.getHistoryQueryExecutorMutex.Lock()
	ret, specificReturn := fake.getHistoryQueryExecutorReturnsOnCall[len(fake.getHistoryQueryExecutorArgsForCall)]
	fake.getHistoryQueryExecutorArgsForCall = append(fake.getHistoryQueryExecutorArgsForCall, struct {
		ledgername string
	}{ledgername})
	fake.recordInvocation("GetHistoryQueryExecutor", []interface{}{ledgername})
	fake.getHistoryQueryExecutorMutex.Unlock()
	if fake.GetHistoryQueryExecutorStub != nil {
		return fake.GetHistoryQueryExecutorStub(ledgername)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getHistoryQueryExecutorReturns.result1, fake.getHistoryQueryExecutorReturns.result2
}

func (fake *Support) GetHistoryQueryExecutorCallCount() int {
	fake.getHistoryQueryExecutorMutex.RLock()
	defer fake.getHistoryQueryExecutorMutex.RUnlock()
	return len(fake.getHistoryQueryExecutorArgsForCall)
}

func (fake *Support) GetHistoryQueryExecutorArgsForCall(i int) string {
	fake.getHistoryQueryExecutorMutex.RLock()
	defer fake.getHistoryQueryExecutorMutex.RUnlock()
	return fake.getHistoryQueryExecutorArgsForCall[i].ledgername
}

func (fake *Support) GetHistoryQueryExecutorReturns(result1 ledger.HistoryQueryExecutor, result2 error) {
	fake.GetHistoryQueryExecutorStub = nil
	fake.getHistoryQueryExecutorReturns = struct {
		result1 ledger.HistoryQueryExecutor
		result2 error
	}{result1, result2}
}

func (fake *Support) GetHistoryQueryExecutorReturnsOnCall(i int, result1 ledger.HistoryQueryExecutor, result2 error) {
	fake.GetHistoryQueryExecutorStub = nil
	if fake.getHistoryQueryExecutorReturnsOnCall == nil {
		fake.getHistoryQueryExecutorReturnsOnCall = make(map[int]struct {
			result1 ledger.HistoryQueryExecutor
			result2 error
		})
	}
	fake.getHistoryQueryExecutorReturnsOnCall[i] = struct {
		result1 ledger.HistoryQueryExecutor
		result2 error
	}{result1, result2}
}

func (fake *Support) GetTransactionByID(chid string, txID string) (*pb.ProcessedTransaction, error) {
	fake.getTransactionByIDMutex.Lock()
	ret, specificReturn := fake.getTransactionByIDReturnsOnCall[len(fake.getTransactionByIDArgsForCall)]
	fake.getTransactionByIDArgsForCall = append(fake.getTransactionByIDArgsForCall, struct {
		chid string
		txID string
	}{chid, txID})
	fake.recordInvocation("GetTransactionByID", []interface{}{chid, txID})
	fake.getTransactionByIDMutex.Unlock()
	if fake.GetTransactionByIDStub != nil {
		return fake.GetTransactionByIDStub(chid, txID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getTransactionByIDReturns.result1, fake.getTransactionByIDReturns.result2
}

func (fake *Support) GetTransactionByIDCallCount() int {
	fake.getTransactionByIDMutex.RLock()
	defer fake.getTransactionByIDMutex.RUnlock()
	return len(fake.getTransactionByIDArgsForCall)
}

func (fake *Support) GetTransactionByIDArgsForCall(i int) (string, string) {
	fake.getTransactionByIDMutex.RLock()
	defer fake.getTransactionByIDMutex.RUnlock()
	return fake.getTransactionByIDArgsForCall[i].chid, fake.getTransactionByIDArgsForCall[i].txID
}

func (fake *Support) GetTransactionByIDReturns(result1 *pb.ProcessedTransaction, result2 error) {
	fake.GetTransactionByIDStub = nil
	fake.getTransactionByIDReturns = struct {
		result1 *pb.ProcessedTransaction
		result2 error
	}{result1, result2}
}

func (fake *Support) GetTransactionByIDReturnsOnCall(i int, result1 *pb.ProcessedTransaction, result2 error) {
	fake.GetTransactionByIDStub = nil
	if fake.getTransactionByIDReturnsOnCall == nil {
		fake.getTransactionByIDReturnsOnCall = make(map[int]struct {
			result1 *pb.ProcessedTransaction
			result2 error
		})
	}
	fake.getTransactionByIDReturnsOnCall[i] = struct {
		result1 *pb.ProcessedTransaction
		result2 error
	}{result1, result2}
}

func (fake *Support) IsSysCC(name string) bool {
	fake.isSysCCMutex.Lock()
	ret, specificReturn := fake.isSysCCReturnsOnCall[len(fake.isSysCCArgsForCall)]
	fake.isSysCCArgsForCall = append(fake.isSysCCArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("IsSysCC", []interface{}{name})
	fake.isSysCCMutex.Unlock()
	if fake.IsSysCCStub != nil {
		return fake.IsSysCCStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isSysCCReturns.result1
}

func (fake *Support) IsSysCCCallCount() int {
	fake.isSysCCMutex.RLock()
	defer fake.isSysCCMutex.RUnlock()
	return len(fake.isSysCCArgsForCall)
}

func (fake *Support) IsSysCCArgsForCall(i int) string {
	fake.isSysCCMutex.RLock()
	defer fake.isSysCCMutex.RUnlock()
	return fake.isSysCCArgsForCall[i].name
}

func (fake *Support) IsSysCCReturns(result1 bool) {
	fake.IsSysCCStub = nil
	fake.isSysCCReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Support) IsSysCCReturnsOnCall(i int, result1 bool) {
	fake.IsSysCCStub = nil
	if fake.isSysCCReturnsOnCall == nil {
		fake.isSysCCReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSysCCReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Support) Execute(ctxt context.Context, cid string, name string, version string, txid string, syscc bool, signedProp *pb.SignedProposal, prop *pb.Proposal, spec interface{}) (*pb.Response, *pb.ChaincodeEvent, error) {
	fake.executeMutex.Lock()
	ret, specificReturn := fake.executeReturnsOnCall[len(fake.executeArgsForCall)]
	fake.executeArgsForCall = append(fake.executeArgsForCall, struct {
		ctxt       context.Context
		cid        string
		name       string
		version    string
		txid       string
		syscc      bool
		signedProp *pb.SignedProposal
		prop       *pb.Proposal
		spec       interface{}
	}{ctxt, cid, name, version, txid, syscc, signedProp, prop, spec})
	fake.recordInvocation("Execute", []interface{}{ctxt, cid, name, version, txid, syscc, signedProp, prop, spec})
	fake.executeMutex.Unlock()
	if fake.ExecuteStub != nil {
		return fake.ExecuteStub(ctxt, cid, name, version, txid, syscc, signedProp, prop, spec)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.executeReturns.result1, fake.executeReturns.result2, fake.executeReturns.result3
}

func (fake *Support) ExecuteCallCount() int {
	fake.executeMutex.RLock()
	defer fake.executeMutex.RUnlock()
	return len(fake.executeArgsForCall)
}

func (fake *Support) ExecuteArgsForCall(i int) (context.Context, string, string, string, string, bool, *pb.SignedProposal, *pb.Proposal, interface{}) {
	fake.executeMutex.RLock()
	defer fake.executeMutex.RUnlock()
	return fake.executeArgsForCall[i].ctxt, fake.executeArgsForCall[i].cid, fake.executeArgsForCall[i].name, fake.executeArgsForCall[i].version, fake.executeArgsForCall[i].txid, fake.executeArgsForCall[i].syscc, fake.executeArgsForCall[i].signedProp, fake.executeArgsForCall[i].prop, fake.executeArgsForCall[i].spec
}

func (fake *Support) ExecuteReturns(result1 *pb.Response, result2 *pb.ChaincodeEvent, result3 error) {
	fake.ExecuteStub = nil
	fake.executeReturns = struct {
		result1 *pb.Response
		result2 *pb.ChaincodeEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Support) ExecuteReturnsOnCall(i int, result1 *pb.Response, result2 *pb.ChaincodeEvent, result3 error) {
	fake.ExecuteStub = nil
	if fake.executeReturnsOnCall == nil {
		fake.executeReturnsOnCall = make(map[int]struct {
			result1 *pb.Response
			result2 *pb.ChaincodeEvent
			result3 error
		})
	}
	fake.executeReturnsOnCall[i] = struct {
		result1 *pb.Response
		result2 *pb.ChaincodeEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Support) GetChaincodeDefinition(ctx context.Context, chainID string, txid string, signedProp *pb.SignedProposal, prop *pb.Proposal, chaincodeID string, txsim ledger.TxSimulator) (resourcesconfig.ChaincodeDefinition, error) {
	fake.getChaincodeDefinitionMutex.Lock()
	ret, specificReturn := fake.getChaincodeDefinitionReturnsOnCall[len(fake.getChaincodeDefinitionArgsForCall)]
	fake.getChaincodeDefinitionArgsForCall = append(fake.getChaincodeDefinitionArgsForCall, struct {
		ctx         context.Context
		chainID     string
		txid        string
		signedProp  *pb.SignedProposal
		prop        *pb.Proposal
		chaincodeID string
		txsim       ledger.TxSimulator
	}{ctx, chainID, txid, signedProp, prop, chaincodeID, txsim})
	fake.recordInvocation("GetChaincodeDefinition", []interface{}{ctx, chainID, txid, signedProp, prop, chaincodeID, txsim})
	fake.getChaincodeDefinitionMutex.Unlock()
	if fake.GetChaincodeDefinitionStub != nil {
		return fake.GetChaincodeDefinitionStub(ctx, chainID, txid, signedProp, prop, chaincodeID, txsim)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getChaincodeDefinitionReturns.result1, fake.getChaincodeDefinitionReturns.result2
}

func (fake *Support) GetChaincodeDefinitionCallCount() int {
	fake.getChaincodeDefinitionMutex.RLock()
	defer fake.getChaincodeDefinitionMutex.RUnlock()
	return len(fake.getChaincodeDefinitionArgsForCall)
}

func (fake *Support) GetChaincodeDefinitionArgsForCall(i int) (context.Context, string, string, *pb.SignedProposal, *pb.Proposal, string, ledger.TxSimulator) {
	fake.getChaincodeDefinitionMutex.RLock()
	defer fake.getChaincodeDefinitionMutex.RUnlock()
	return fake.getChaincodeDefinitionArgsForCall[i].ctx, fake.getChaincodeDefinitionArgsForCall[i].chainID, fake.getChaincodeDefinitionArgsForCall[i].txid, fake.getChaincodeDefinitionArgsForCall[i].signedProp, fake.getChaincodeDefinitionArgsForCall[i].prop, fake.getChaincodeDefinitionArgsForCall[i].chaincodeID, fake.getChaincodeDefinitionArgsForCall[i].txsim
}

func (fake *Support) GetChaincodeDefinitionReturns(result1 resourcesconfig.ChaincodeDefinition, result2 error) {
	fake.GetChaincodeDefinitionStub = nil
	fake.getChaincodeDefinitionReturns = struct {
		result1 resourcesconfig.ChaincodeDefinition
		result2 error
	}{result1, result2}
}

func (fake *Support) GetChaincodeDefinitionReturnsOnCall(i int, result1 resourcesconfig.ChaincodeDefinition, result2 error) {
	fake.GetChaincodeDefinitionStub = nil
	if fake.getChaincodeDefinitionReturnsOnCall == nil {
		fake.getChaincodeDefinitionReturnsOnCall = make(map[int]struct {
			result1 resourcesconfig.ChaincodeDefinition
			result2 error
		})
	}
	fake.getChaincodeDefinitionReturnsOnCall[i] = struct {
		result1 resourcesconfig.ChaincodeDefinition
		result2 error
	}{result1, result2}
}

func (fake *Support) CheckACL(signedProp *pb.SignedProposal, chdr *common.ChannelHeader, shdr *common.SignatureHeader, hdrext *pb.ChaincodeHeaderExtension) error {
	fake.checkACLMutex.Lock()
	ret, specificReturn := fake.checkACLReturnsOnCall[len(fake.checkACLArgsForCall)]
	fake.checkACLArgsForCall = append(fake.checkACLArgsForCall, struct {
		signedProp *pb.SignedProposal
		chdr       *common.ChannelHeader
		shdr       *common.SignatureHeader
		hdrext     *pb.ChaincodeHeaderExtension
	}{signedProp, chdr, shdr, hdrext})
	fake.recordInvocation("CheckACL", []interface{}{signedProp, chdr, shdr, hdrext})
	fake.checkACLMutex.Unlock()
	if fake.CheckACLStub != nil {
		return fake.CheckACLStub(signedProp, chdr, shdr, hdrext)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.checkACLReturns.result1
}

func (fake *Support) CheckACLCallCount() int {
	fake.checkACLMutex.RLock()
	defer fake.checkACLMutex.RUnlock()
	return len(fake.checkACLArgsForCall)
}

func (fake *Support) CheckACLArgsForCall(i int) (*pb.SignedProposal, *common.ChannelHeader, *common.SignatureHeader, *pb.ChaincodeHeaderExtension) {
	fake.checkACLMutex.RLock()
	defer fake.checkACLMutex.RUnlock()
	return fake.checkACLArgsForCall[i].signedProp, fake.checkACLArgsForCall[i].chdr, fake.checkACLArgsForCall[i].shdr, fake.checkACLArgsForCall[i].hdrext
}

func (fake *Support) CheckACLReturns(result1 error) {
	fake.CheckACLStub = nil
	fake.checkACLReturns = struct {
		result1 error
	}{result1}
}

func (fake *Support) CheckACLReturnsOnCall(i int, result1 error) {
	fake.CheckACLStub = nil
	if fake.checkACLReturnsOnCall == nil {
		fake.checkACLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkACLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Support) IsJavaCC(buf []byte) (bool, error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.isJavaCCMutex.Lock()
	ret, specificReturn := fake.isJavaCCReturnsOnCall[len(fake.isJavaCCArgsForCall)]
	fake.isJavaCCArgsForCall = append(fake.isJavaCCArgsForCall, struct {
		buf []byte
	}{bufCopy})
	fake.recordInvocation("IsJavaCC", []interface{}{bufCopy})
	fake.isJavaCCMutex.Unlock()
	if fake.IsJavaCCStub != nil {
		return fake.IsJavaCCStub(buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.isJavaCCReturns.result1, fake.isJavaCCReturns.result2
}

func (fake *Support) IsJavaCCCallCount() int {
	fake.isJavaCCMutex.RLock()
	defer fake.isJavaCCMutex.RUnlock()
	return len(fake.isJavaCCArgsForCall)
}

func (fake *Support) IsJavaCCArgsForCall(i int) []byte {
	fake.isJavaCCMutex.RLock()
	defer fake.isJavaCCMutex.RUnlock()
	return fake.isJavaCCArgsForCall[i].buf
}

func (fake *Support) IsJavaCCReturns(result1 bool, result2 error) {
	fake.IsJavaCCStub = nil
	fake.isJavaCCReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Support) IsJavaCCReturnsOnCall(i int, result1 bool, result2 error) {
	fake.IsJavaCCStub = nil
	if fake.isJavaCCReturnsOnCall == nil {
		fake.isJavaCCReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isJavaCCReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *Support) CheckInstantiationPolicy(name string, version string, cd resourcesconfig.ChaincodeDefinition) error {
	fake.checkInstantiationPolicyMutex.Lock()
	ret, specificReturn := fake.checkInstantiationPolicyReturnsOnCall[len(fake.checkInstantiationPolicyArgsForCall)]
	fake.checkInstantiationPolicyArgsForCall = append(fake.checkInstantiationPolicyArgsForCall, struct {
		name    string
		version string
		cd      resourcesconfig.ChaincodeDefinition
	}{name, version, cd})
	fake.recordInvocation("CheckInstantiationPolicy", []interface{}{name, version, cd})
	fake.checkInstantiationPolicyMutex.Unlock()
	if fake.CheckInstantiationPolicyStub != nil {
		return fake.CheckInstantiationPolicyStub(name, version, cd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.checkInstantiationPolicyReturns.result1
}

func (fake *Support) CheckInstantiationPolicyCallCount() int {
	fake.checkInstantiationPolicyMutex.RLock()
	defer fake.checkInstantiationPolicyMutex.RUnlock()
	return len(fake.checkInstantiationPolicyArgsForCall)
}

func (fake *Support) CheckInstantiationPolicyArgsForCall(i int) (string, string, resourcesconfig.ChaincodeDefinition) {
	fake.checkInstantiationPolicyMutex.RLock()
	defer fake.checkInstantiationPolicyMutex.RUnlock()
	return fake.checkInstantiationPolicyArgsForCall[i].name, fake.checkInstantiationPolicyArgsForCall[i].version, fake.checkInstantiationPolicyArgsForCall[i].cd
}

func (fake *Support) CheckInstantiationPolicyReturns(result1 error) {
	fake.CheckInstantiationPolicyStub = nil
	fake.checkInstantiationPolicyReturns = struct {
		result1 error
	}{result1}
}

func (fake *Support) CheckInstantiationPolicyReturnsOnCall(i int, result1 error) {
	fake.CheckInstantiationPolicyStub = nil
	if fake.checkInstantiationPolicyReturnsOnCall == nil {
		fake.checkInstantiationPolicyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkInstantiationPolicyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Support) GetChaincodeDeploymentSpecFS(cds *pb.ChaincodeDeploymentSpec) (*pb.ChaincodeDeploymentSpec, error) {
	fake.getChaincodeDeploymentSpecFSMutex.Lock()
	ret, specificReturn := fake.getChaincodeDeploymentSpecFSReturnsOnCall[len(fake.getChaincodeDeploymentSpecFSArgsForCall)]
	fake.getChaincodeDeploymentSpecFSArgsForCall = append(fake.getChaincodeDeploymentSpecFSArgsForCall, struct {
		cds *pb.ChaincodeDeploymentSpec
	}{cds})
	fake.recordInvocation("GetChaincodeDeploymentSpecFS", []interface{}{cds})
	fake.getChaincodeDeploymentSpecFSMutex.Unlock()
	if fake.GetChaincodeDeploymentSpecFSStub != nil {
		return fake.GetChaincodeDeploymentSpecFSStub(cds)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getChaincodeDeploymentSpecFSReturns.result1, fake.getChaincodeDeploymentSpecFSReturns.result2
}

func (fake *Support) GetChaincodeDeploymentSpecFSCallCount() int {
	fake.getChaincodeDeploymentSpecFSMutex.RLock()
	defer fake.getChaincodeDeploymentSpecFSMutex.RUnlock()
	return len(fake.getChaincodeDeploymentSpecFSArgsForCall)
}

func (fake *Support) GetChaincodeDeploymentSpecFSArgsForCall(i int) *pb.ChaincodeDeploymentSpec {
	fake.getChaincodeDeploymentSpecFSMutex.RLock()
	defer fake.getChaincodeDeploymentSpecFSMutex.RUnlock()
	return fake.getChaincodeDeploymentSpecFSArgsForCall[i].cds
}

func (fake *Support) GetChaincodeDeploymentSpecFSReturns(result1 *pb.ChaincodeDeploymentSpec, result2 error) {
	fake.GetChaincodeDeploymentSpecFSStub = nil
	fake.getChaincodeDeploymentSpecFSReturns = struct {
		result1 *pb.ChaincodeDeploymentSpec
		result2 error
	}{result1, result2}
}

func (fake *Support) GetChaincodeDeploymentSpecFSReturnsOnCall(i int, result1 *pb.ChaincodeDeploymentSpec, result2 error) {
	fake.GetChaincodeDeploymentSpecFSStub = nil
	if fake.getChaincodeDeploymentSpecFSReturnsOnCall == nil {
		fake.getChaincodeDeploymentSpecFSReturnsOnCall = make(map[int]struct {
			result1 *pb.ChaincodeDeploymentSpec
			result2 error
		})
	}
	fake.getChaincodeDeploymentSpecFSReturnsOnCall[i] = struct {
		result1 *pb.ChaincodeDeploymentSpec
		result2 error
	}{result1, result2}
}

func (fake *Support) GetApplicationConfig(cid string) (channelconfig.Application, bool) {
	fake.getApplicationConfigMutex.Lock()
	ret, specificReturn := fake.getApplicationConfigReturnsOnCall[len(fake.getApplicationConfigArgsForCall)]
	fake.getApplicationConfigArgsForCall = append(fake.getApplicationConfigArgsForCall, struct {
		cid string
	}{cid})
	fake.recordInvocation("GetApplicationConfig", []interface{}{cid})
	fake.getApplicationConfigMutex.Unlock()
	if fake.GetApplicationConfigStub != nil {
		return fake.GetApplicationConfigStub(cid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getApplicationConfigReturns.result1, fake.getApplicationConfigReturns.result2
}

func (fake *Support) GetApplicationConfigCallCount() int {
	fake.getApplicationConfigMutex.RLock()
	defer fake.getApplicationConfigMutex.RUnlock()
	return len(fake.getApplicationConfigArgsForCall)
}

func (fake *Support) GetApplicationConfigArgsForCall(i int) string {
	fake.getApplicationConfigMutex.RLock()
	defer fake.getApplicationConfigMutex.RUnlock()
	return fake.getApplicationConfigArgsForCall[i].cid
}

func (fake *Support) GetApplicationConfigReturns(result1 channelconfig.Application, result2 bool) {
	fake.GetApplicationConfigStub = nil
	fake.getApplicationConfigReturns = struct {
		result1 channelconfig.Application
		result2 bool
	}{result1, result2}
}

func (fake *Support) GetApplicationConfigReturnsOnCall(i int, result1 channelconfig.Application, result2 bool) {
	fake.GetApplicationConfigStub = nil
	if fake.getApplicationConfigReturnsOnCall == nil {
		fake.getApplicationConfigReturnsOnCall = make(map[int]struct {
			result1 channelconfig.Application
			result2 bool
		})
	}
	fake.getApplicationConfigReturnsOnCall[i] = struct {
		result1 channelconfig.Application
		result2 bool
	}{result1, result2}
}

func (fake *Support) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isSysCCAndNotInvokableExternalMutex.RLock()
	defer fake.isSysCCAndNotInvokableExternalMutex.RUnlock()
	fake.getTxSimulatorMutex.RLock()
	defer fake.getTxSimulatorMutex.RUnlock()
	fake.getHistoryQueryExecutorMutex.RLock()
	defer fake.getHistoryQueryExecutorMutex.RUnlock()
	fake.getTransactionByIDMutex.RLock()
	defer fake.getTransactionByIDMutex.RUnlock()
	fake.isSysCCMutex.RLock()
	defer fake.isSysCCMutex.RUnlock()
	fake.executeMutex.RLock()
	defer fake.executeMutex.RUnlock()
	fake.getChaincodeDefinitionMutex.RLock()
	defer fake.getChaincodeDefinitionMutex.RUnlock()
	fake.checkACLMutex.RLock()
	defer fake.checkACLMutex.RUnlock()
	fake.isJavaCCMutex.RLock()
	defer fake.isJavaCCMutex.RUnlock()
	fake.checkInstantiationPolicyMutex.RLock()
	defer fake.checkInstantiationPolicyMutex.RUnlock()
	fake.getChaincodeDeploymentSpecFSMutex.RLock()
	defer fake.getChaincodeDeploymentSpecFSMutex.RUnlock()
	fake.getApplicationConfigMutex.RLock()
	defer fake.getApplicationConfigMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Support) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
